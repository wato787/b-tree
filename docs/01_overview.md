# 01. Bツリー概要（用語・不変条件）

この教材では **最小次数 \(t\)** を使ってBツリーを説明します（CLRSの流儀）。

## Bツリーとは

「**1ノードに複数キーを持てる平衡探索木**」です。1ノードが複数キーを持つため、ディスク/SSDなど **ブロックI/O** に強いデータ構造として有名です（1回のI/Oで多くのキーを読む）。

一方、学習として重要なのは次の2点です。

- **分割（split）** によって「高さ」を増やしにくくする
- **借用（borrow）/併合（merge）** によって削除後の「スカスカ」を直す

## 用語

- **キー（key）**: 探索したい値。ここでは `int`。
- **ノード（node）**: 複数キーと、必要なら複数の子ポインタを持つ箱。
- **葉（leaf）**: 子を持たないノード。
- **内部ノード（internal node）**: 子を持つノード。
- **最小次数 \(t\)**: ノードの「太さ」を決めるパラメータ（\(t \ge 2\)）。

## 不変条件（invariants）

### 1) 各ノードのキーは昇順で重複なし

ノード内のキー配列は常に

```
k0 < k1 < k2 < ... < km-1
```

です。これで二分探索ができます。

### 2)（root以外の）キー数は範囲に収まる

最小次数 \(t\) のとき、root以外のノードは

- 最小: \(t-1\) 個
- 最大: \(2t-1\) 個

のキーを持ちます。

rootは例外で、空の木を表すために「0個」を許したり、成長の過程で一時的に少なくなったりします。

### 3) 内部ノードの子の数は `keys+1`

内部ノードがキーを `m` 個持つなら、子は必ず `m+1` 個です。

```
[ k0, k1, ..., k(m-1) ]
  c0  c1        cm
```

### 4) すべての葉が同じ深さ

これが「平衡」の根拠です。探索/挿入/削除が \(O(\log n)\) に収まります。

### 5) 部分木の値域（レンジ）がキーで区切られる

内部ノードのキー `k(i-1), k(i)` に挟まれた子 `c(i)` は必ず

```
k(i-1) < (c(i) の全キー) < k(i)
```

を満たします（端の子は片側だけ制約）。

## 実装との対応

この教材の実装は `btree.Validate()` で上の不変条件を検査できます。

- ノード分割: `node.splitChild`
- いっぱいでないノードへの挿入: `node.insertNonFull`
- 削除: `node.delete`（借用/併合を含む）
- 不変条件検証: `node.validateRec`

