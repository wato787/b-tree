# 03. 削除（Delete）— 借用（borrow）と併合（merge）

削除は挿入より分岐が多いです。ポイントは **「降りる前に子を太らせる（t個以上にする）」** です。

## ゴール

キー `k` を削除したあとも、不変条件（特に「root以外は最低 t-1 キー」）を維持する。

## 大枠（教科書的な分岐）

削除対象 `k` が「いま見ているノード」にあるかどうかで分かれます。

### A) このノードに `k` がある

#### A-1) そのノードが葉

配列から削除して終わり。

#### A-2) そのノードが内部ノード

内部ノードからキーを消すと、レンジ境界が崩れるので「置換」が必要です。

- 左の子（前者部分木）が **t個以上のキー** を持つなら
  - **前駆（predecessor）**（左部分木の最大）で `k` を置換し、その前駆を左部分木から削除
- 右の子（後者部分木）が **t個以上** を持つなら
  - **後継（successor）**（右部分木の最小）で置換し、その後継を右部分木から削除
- どちらも **t-1** しか持たないなら
  - 左子 + `k` + 右子を **併合（merge）** して1つのノードにし、そこから `k` を削除

実装: `node.delete` の「ケース1」。

### B) このノードに `k` がない（子へ降りる）

このときの核心は：

> 降りる子が t-1 個しかキーを持たないなら、降りる前に必ず「借用 or 併合」で t 個以上にしておく

こうすると、下層で削除が起きても「最低 t-1」を割りにくくなり、処理がシンプルになります。

実装: `ensureChildHasAtLeastTKeys`（借用 or 併合）。

## 借用（borrow）のイメージ

親と兄弟を介して、キーを1つ融通します。

### 左兄弟から借りる（borrowFromPrev）

- 親の境界キーを子へ 내려す（子の先頭へ）
- 左兄弟の最大キーを親の境界に上げる
- （内部ノードなら）左兄弟の最後の子も一緒に移動

### 右兄弟から借りる（borrowFromNext）

- 親の境界キーを子へ 내려す（子の末尾へ）
- 右兄弟の最小キーを親の境界に上げる
- （内部ノードなら）右兄弟の最初の子も一緒に移動

## 併合（merge）のイメージ

兄弟がどちらも t-1 個しかキーを持たないとき、借用できないので「合体」します。

```
left + parentKey + right  ->  merged(left)
```

親からは `parentKey` と `right` が消え、子が1つ減ります。

## root が空になったら高さを下げる

削除後に root のキー数が 0 になり、内部ノードなら、唯一の子を新rootにできます。
これで木の高さが1下がります。

実装: `BTree.Delete` の末尾付近。

