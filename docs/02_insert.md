# 02. 挿入（Insert）と分割（split）

挿入の核心は **「満杯ノードに降りない」** ことです。

## ゴール

キー `k` を挿入したあとも、Bツリーの不変条件を壊さない。

特に重要なのは：

- ノードのキー数が最大 \(2t-1\) を超えない
- すべての葉の深さがそろう

## 方針（満杯を事前に割る）

### 1) rootが満杯なら、先に高さを1上げて分割する

root が満杯（キー数 \(2t-1\)）のとき、rootをそのまま分割すると「親」が必要になります。
そこで、

1. 新しいrootを作る
2. 古いrootをその子にする
3. その子（古いroot）を split する

という手順で「親」を用意します。

実装: `BTree.Insert` の最初の方。

### 2) insertNonFull（いっぱいではないノードへの挿入）

ノード `x` が **満杯ではない** ことを保証できているとき、

- `x` が葉なら：キー配列に挿入（配列の差し込み）
- `x` が内部なら：降りる先の子が満杯なら先にsplitしてから降りる

この「降りる前に split」を徹底すると、最下層まで安全に降りられます。

実装: `node.insertNonFull`。

## splitChild のイメージ

最小次数 \(t\) のとき、満杯ノード `y` はキーを \(2t-1\) 個持っています。

```
y.keys = [ k0, k1, ..., k(t-2), k(t-1), k(t), ..., k(2t-2) ]
                 ^ median
```

これを分割すると：

- **中央値 `k(t-1)`** が親へ昇格
- 左ノードは `t-1` 個（`k0..k(t-2)`）
- 右ノードも `t-1` 個（`k(t)..k(2t-2)`）

実装: `node.splitChild`。

## 追ってみる練習

`t=2`（2-3-4木）で、次を挿入してみてください：

```
10, 20, 5, 6, 12, 30, 7, 17
```

`cmd/btree-demo` で `-print` を付けると、各レベルのノードのキー配列が見えます。

